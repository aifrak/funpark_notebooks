<!-- livebook:{"persist_outputs":true} -->

# Coordinate Tasks with Effect

```elixir
Mix.install([
  {:fun_park,
    git: "https://github.com/JKWA/funpark_notebooks.git",
    branch: "main"
  }
])
```

## Advanced Functional Programming with Elixir

|                                                                                                    |                                                                                                                                                                               |
| -------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <img src="https://www.joekoski.com/assets/images/jkelixir_small.jpg" alt="Book cover" width="120"> | **Interactive Examples from Chapter 10**<br/>[Advanced Functional Programming with Elixir](https://pragprog.com/titles/jkelixir/advanced-functional-programming-with-elixir). |

## Build the Effect

````markdown
```elixir
def pure(value) do
  %__MODULE__{
    effect: fn _env ->
      Task.async(fn -> Either.Right.pure(value) end)
    end
  }
end
```
````

````markdown
```elixir
def pure(value) do
  %__MODULE__{
    effect: fn _env ->
      Task.async(fn -> Either.Left.pure(value) end)
    end
  }
end
```
````

````markdown
```elixir
def run(effect, env \\ %{}) do
  effect.effect.(env)
  |> execute_effect()
end
```
````

Let's start with a basic Effect, wrapping the number 40:

```elixir
effect = FunPark.Monad.Effect.pure(40)
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Effect.Right{effect: #Function<2.126265695/1 in FunPark.Monad.Effect.Right.pure/1>}
```

If we run it:

```elixir
FunPark.Monad.Effect.run(effect)
```

<!-- livebook:{"output":true} -->

```
Task completed in 3ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{right: 40}
```

An Elixir Task can fail. For example, we can create an Effect that contains a bomb to crash the underlying process:

```elixir
bomb = fn -> raise "boom" end
bomb_effect = FunPark.Monad.Effect.lift_func(bomb)
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Effect.Right{effect: #Function<4.9888490/1 in FunPark.Monad.Effect.lift_func/1>}
```

If we run it:

```elixir
FunPark.Monad.Effect.run(bomb_effect)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Left{
  left: %FunPark.Errors.EffectError{stage: :lift_func, reason: %RuntimeError{message: "boom"}}
}
```

An Effect can also fail by timing out. Here is an Effect that takes 6 seconds, one more than our Task default:

```elixir
long_delay = fn -> Process.sleep(6000) end
long_delay_effect = FunPark.Monad.Effect.lift_func(long_delay)
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Effect.Right{effect: #Function<4.9888490/1 in FunPark.Monad.Effect.lift_func/1>}
```

And if we run this long task:

```elixir
FunPark.Monad.Effect.run(long_delay_effect)
```

<!-- livebook:{"output":true} -->

```
Task completed in 5001ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Left{left: %FunPark.Errors.EffectError{stage: :run, reason: :timeout}}
```

## Deferred Transformation

````markdown
```elixir
def map(%__MODULE__{effect: effect_fn}, function) do
  %__MODULE__{
    effect: fn env ->
      Task.async(fn ->
        effect_fn.(env)
        |> Task.await()
        |> case do
          %Either.Right{right: value} ->
            try do
              Either.Right.pure(function.(value))
            rescue
              e -> Either.Left.pure(EffectError.new(:map, e))
            end
          
          %Either.Left{} = left -> left
        end
      end)
    end
  }
end
```
````

````markdown
```elixir
def map(%__MODULE__{effect: effect_fn}, _function) do
  %__MODULE__{effect: effect_fn}
end
```
````

Let's start with the Effect that, when run, returns the value 5:

```elixir
five_effect = FunPark.Monad.Effect.pure(5)
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Effect.Right{effect: #Function<2.126265695/1 in FunPark.Monad.Effect.Right.pure/1>}
```

And a simple function that adds one to the value submitted:

```elixir
increment = fn v -> v + 1 end
```

<!-- livebook:{"output":true} -->

```
#Function<42.81571850/1 in :erl_eval.expr/6>
```

We can compose a new Effect by mapping increment/1 to five_effect:

```elixir
six_effect = five_effect |> FunPark.Monad.map(increment)
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Effect.Right{
  effect: #Function<2.796317/1 in FunPark.Monad.FunPark.Monad.Effect.Right.map/2>
}
```

Now, when we run it in a protected boundary:

```elixir
FunPark.Monad.Effect.run(six_effect)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{right: 6}
```

Let's see what happens when we start with the letter "A":

```elixir
alpha_effect = FunPark.Monad.Effect.pure("A")
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Effect.Right{effect: #Function<2.126265695/1 in FunPark.Monad.Effect.Right.pure/1>}
```

And compose it with increment/1:

```elixir
error_effect = alpha_effect |> FunPark.Monad.map(increment)
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Effect.Right{
  effect: #Function<2.796317/1 in FunPark.Monad.FunPark.Monad.Effect.Right.map/2>
}
```

When we execute it in our controlled boundary:

```elixir
FunPark.Monad.Effect.run(error_effect)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 2ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Left{
  left: %FunPark.Errors.EffectError{
    stage: :map,
    reason: %ArithmeticError{message: "bad argument in arithmetic expression"}
  }
}
```

Let's lift increment/1:

```elixir
increment_effect = FunPark.Monad.Effect.from_try(increment)
```

<!-- livebook:{"output":true} -->

```
#Function<2.9888490/1 in FunPark.Monad.Effect.from_try/1>
```

And how do we compose with a Kleisli function? Use bind/2:

```elixir
error_effect_bind = alpha_effect |> FunPark.Monad.bind(increment_effect)
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Effect.Right{
  effect: #Function<1.796317/1 in FunPark.Monad.FunPark.Monad.Effect.Right.bind/2>
}
```

And now, when we run it:

```elixir
FunPark.Monad.Effect.run(error_effect_bind)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Left{left: %ArithmeticError{message: "bad argument in arithmetic expression"}}
```

I/O typically takes time, so let's simulate this with a half-second delay:

```elixir
delay = fn value -> Process.sleep(500); value end
```

<!-- livebook:{"output":true} -->

```
#Function<42.81571850/1 in :erl_eval.expr/6>
```

and map it to our six_effect:

```elixir
long_six_effect = six_effect |> FunPark.Monad.map(delay)
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Effect.Right{
  effect: #Function<2.796317/1 in FunPark.Monad.FunPark.Monad.Effect.Right.map/2>
}
```

And when we run it in our protected boundary:

```elixir
FunPark.Monad.Effect.run(long_six_effect)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{right: 6}
```

## Effectful Store

````markdown
```elixir
def add(%Ride{} = ride, table_name) when is_atom(table_name) do
  Effect.lift_either(fn ->
    Process.sleep(500)
    Store.insert_item(ride, table_name)
  end)
end
```
````

````markdown
```elixir
def get(%Ride{id: id}, table_name) when is_atom(table_name) do
  Effect.lift_either(fn ->
    Process.sleep(500)
    case Store.get_item(id, table_name) do
      %Either.Right{right: data} -> Either.Right.pure(struct(Ride, data))
      %Either.Left{} = left -> left
    end
  end)
end
```
````

````markdown
```elixir
def remove(%Ride{id: id}, table_name) when is_atom(table_name) do
  Effect.lift_either(fn ->
    Process.sleep(500)
    Store.delete_item(id, table_name)
  end)
end
```
````

Let's start by adding a :schedule table to our ETS store:

```elixir
FunPark.Store.create_table(:schedule)
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{right: :schedule}
```

Then generate the Apple Cart ride:

```elixir
apple = FunPark.Ride.make("Apple Cart")
```

<!-- livebook:{"output":true} -->

```
%FunPark.Ride{
  id: 1219,
  name: "Apple Cart",
  min_age: 0,
  min_height: 0,
  wait_time: 0,
  online: true,
  tags: []
}
```

And create the effects for managing the Apple Cart:

```elixir
save_effect = FunPark.Maintenance.Store.add(apple, :schedule)
get_effect = FunPark.Maintenance.Store.get(apple, :schedule)
remove_effect = FunPark.Maintenance.Store.remove(apple, :schedule)
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Effect.Right{effect: #Function<5.9888490/1 in FunPark.Monad.Effect.map_left/2>}
```

We can run the save Effect:

```elixir
FunPark.Monad.Effect.run(save_effect)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{
  right: %FunPark.Ride{
    id: 1219,
    name: "Apple Cart",
    min_age: 0,
    min_height: 0,
    wait_time: 0,
    online: true,
    tags: []
  }
}
```

If we ask the store for Apple Cart:

```elixir
FunPark.Monad.Effect.run(get_effect)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{
  right: %{
    id: 1219,
    name: "Apple Cart",
    tags: [],
    wait_time: 0,
    min_age: 0,
    min_height: 0,
    online: true
  }
}
```

Now, if we remove Apple Cart:

```elixir
FunPark.Monad.Effect.run(remove_effect)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{right: 1219}
```

And if we rerun the get_effect:

```elixir
FunPark.Monad.Effect.run(get_effect)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Left{left: :not_found}
```

We can also drop the entire table:

```elixir
FunPark.Store.drop_table(:schedule)
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{right: :schedule}
```

And when we run the get Effect again:

```elixir
FunPark.Monad.Effect.run(get_effect)
```

<!-- livebook:{"output":true} -->

```
Task completed in 15ms
Task completed in 516ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Left{
  left: %ArgumentError{
    message: "errors were found at the given arguments:\n\n  * 1st argument: the table identifier does not refer to an existing ETS table\n"
  }
}
```

## Maintenance Repository

````markdown
```elixir
def create_store do
  tables = [:schedule, :unschedule, :lockout, :compliance]
  
  tables
  |> Enum.map(&Store.create_table/1)
  |> Either.sequence_a()
end
```
````

Success is represented by Right with the list of successfully created tables:

```elixir
FunPark.Maintenance.Repo.create_store()
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{right: [:schedule, :unschedule, :lockout, :compliance]}
```

But if we run it again:

```elixir
FunPark.Maintenance.Repo.create_store()
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Left{
  left: [
    %ArgumentError{
      message: "errors were found at the given arguments:\n\n  * 1st argument: table name already exists\n"
    },
    %ArgumentError{
      message: "errors were found at the given arguments:\n\n  * 1st argument: table name already exists\n"
    },
    %ArgumentError{
      message: "errors were found at the given arguments:\n\n  * 1st argument: table name already exists\n"
    },
    %ArgumentError{
      message: "errors were found at the given arguments:\n\n  * 1st argument: table name already exists\n"
    }
  ]
}
```

````markdown
```elixir
def validate_ride_effect(%Ride{} = ride) do
  Effect.lift_either(fn -> Ride.validate(ride) end)
end
```
````

````markdown
```elixir
def add_to_store_effect(%Ride{} = ride) do
  Effect.asks(fn %{table: table_name} ->
    Maintenance.Store.add(ride, table_name)
  end)
  |> Effect.bind(& &1)
end
```
````

````markdown
```elixir
def add_ride_effect(%Ride{} = ride) do
  ride
  |> validate_ride_effect()
  |> Monad.bind(&add_to_store_effect/1)
end
```
````

Let's start by creating our store and making a ride:

```elixir
FunPark.Maintenance.Repo.create_store()
apple = FunPark.Ride.make("Apple Cart")
```

<!-- livebook:{"output":true} -->

```
%FunPark.Ride{
  id: 1283,
  name: "Apple Cart",
  min_age: 0,
  min_height: 0,
  wait_time: 0,
  online: true,
  tags: []
}
```

Next, create an Effect to add the Apple Cart to scheduled maintenance:

```elixir
effect = FunPark.Maintenance.Repo.add_ride_effect(apple)
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Effect.Right{
  effect: #Function<1.796317/1 in FunPark.Monad.FunPark.Monad.Effect.Right.bind/2>
}
```

And finally execute our Effect with the table name:

```elixir
FunPark.Monad.Effect.run(effect, %{table: :schedule})
```

<!-- livebook:{"output":true} -->

```
Task completed in 12ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 513ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{
  right: %FunPark.Ride{
    id: 1283,
    name: "Apple Cart",
    min_age: 0,
    min_height: 0,
    wait_time: 0,
    online: true,
    tags: []
  }
}
```

````markdown
```elixir
def add_schedule(%Ride{} = ride) do
  ride
  |> add_ride_effect()
  |> Effect.run(%{table: :schedule})
end
```
````

Let's modify the Apple Cart with an invalid wait time:

```elixir
invalid_apple = FunPark.Ride.change(apple, %{wait_time: -10})
```

<!-- livebook:{"output":true} -->

```
%FunPark.Ride{
  id: 1283,
  name: "Apple Cart",
  min_age: 0,
  min_height: 0,
  wait_time: -10,
  online: true,
  tags: []
}
```

Now, when we try to save it:

```elixir
FunPark.Maintenance.Repo.add_schedule(invalid_apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 11ms
Task completed in 11ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Left{
  left: %FunPark.Errors.ValidationError{errors: ["Apple Cart: wait time must be non negative"]}
}
```

If we delete the underlying table:

```elixir
FunPark.Store.drop_table(:schedule)
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{right: :schedule}
```

And pass it a valid ride:

```elixir
FunPark.Maintenance.Repo.add_schedule(apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Left{
  left: %ArgumentError{
    message: "errors were found at the given arguments:\n\n  * 1st argument: the table identifier does not refer to an existing ETS table\n"
  }
}
```

````markdown
```elixir
def add_unschedule(%Ride{} = ride) do
  ride |> add_ride_effect() |> Effect.run(%{table: :unschedule})
end

def add_lockout(%Ride{} = ride) do
  ride |> add_ride_effect() |> Effect.run(%{table: :lockout})
end

def add_compliance(%Ride{} = ride) do
  ride |> add_ride_effect() |> Effect.run(%{table: :compliance})
end
```
````

````markdown
```elixir
def add_to_all(%Ride{} = ride) do
  ride
  |> Maintenance.Repo.add_schedule()
  |> Monad.bind(fn _ -> Maintenance.Repo.add_unschedule(ride) end)
  |> Monad.bind(fn _ -> Maintenance.Repo.add_lockout(ride) end)
  |> Monad.bind(fn _ -> Maintenance.Repo.add_compliance(ride) end)
end
```
````

Let's start by generating a ride and making sure the store has all the tables:

```elixir
apple = FunPark.Ride.make("Apple Cart")
FunPark.Maintenance.Repo.create_store()
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Left{
  left: [
    %ArgumentError{
      message: "errors were found at the given arguments:\n\n  * 1st argument: table name already exists\n"
    },
    %ArgumentError{
      message: "errors were found at the given arguments:\n\n  * 1st argument: table name already exists\n"
    },
    %ArgumentError{
      message: "errors were found at the given arguments:\n\n  * 1st argument: table name already exists\n"
    },
    %ArgumentError{
      message: "errors were found at the given arguments:\n\n  * 1st argument: table name already exists\n"
    }
  ]
}
```

Now we can add our ride to all the maintenance tables:

```elixir
FunPark.Maintenance.add_to_all(apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 503ms
Task completed in 503ms
Task completed in 503ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 503ms
Task completed in 503ms
Task completed in 503ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{
  right: %FunPark.Ride{
    id: 1411,
    name: "Apple Cart",
    min_age: 0,
    min_height: 0,
    wait_time: 0,
    online: true,
    tags: []
  }
}
```

````markdown
```elixir
def remove_from_store_effect(%Ride{} = ride) do
  Effect.asks(fn %{table: table_name} ->
    Maintenance.Store.remove(ride, table_name)
  end)
  |> Effect.bind(& &1)
end
```
````

````markdown
```elixir
def remove_ride_effect(%Ride{} = ride) do
  ride
  |> validate_ride_effect()
  |> Monad.bind(&remove_from_store_effect/1)
  |> Monad.map(fn _ -> ride end)
end
```
````

````markdown
```elixir
def remove_schedule(%Ride{} = ride) do
  ride |> remove_ride_effect() |> Effect.run(%{table: :schedule})
end

def remove_unschedule(%Ride{} = ride) do
  ride |> remove_ride_effect() |> Effect.run(%{table: :unschedule})
end

def remove_lockout(%Ride{} = ride) do
  ride |> remove_ride_effect() |> Effect.run(%{table: :lockout})
end

def remove_compliance(%Ride{} = ride) do
  ride |> remove_ride_effect() |> Effect.run(%{table: :compliance})
end
```
````

````markdown
```elixir
def remove_from_all(%Ride{} = ride) do
  operations = [
    &Maintenance.Repo.remove_schedule/1,
    &Maintenance.Repo.remove_unschedule/1,
    &Maintenance.Repo.remove_lockout/1,
    &Maintenance.Repo.remove_compliance/1
  ]
  
  operations
  |> Either.traverse_a(& &1.(ride))
  |> Monad.map(fn _ -> ride end)
end
```
````

First, let's create our store and make an Apple Cart ride:

```elixir
FunPark.Maintenance.Repo.create_store()
apple = FunPark.Ride.make("Apple Cart")
```

<!-- livebook:{"output":true} -->

```
%FunPark.Ride{
  id: 1475,
  name: "Apple Cart",
  min_age: 0,
  min_height: 0,
  wait_time: 0,
  online: true,
  tags: []
}
```

We can add the Apple Cart to all maintenance tables:

```elixir
FunPark.Maintenance.add_to_all(apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{
  right: %FunPark.Ride{
    id: 1475,
    name: "Apple Cart",
    min_age: 0,
    min_height: 0,
    wait_time: 0,
    online: true,
    tags: []
  }
}
```

and remove it as well:

```elixir
FunPark.Maintenance.remove_from_all(apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{
  right: %FunPark.Ride{
    id: 1475,
    name: "Apple Cart",
    min_age: 0,
    min_height: 0,
    wait_time: 0,
    online: true,
    tags: []
  }
}
```

But if we create an invalid Apple Cart:

```elixir
invalid_apple = FunPark.Ride.change(apple, %{wait_time: -10})
```

<!-- livebook:{"output":true} -->

```
%FunPark.Ride{
  id: 1475,
  name: "Apple Cart",
  min_age: 0,
  min_height: 0,
  wait_time: -10,
  online: true,
  tags: []
}
```

The difference matters, adding Apple Cart to all our tables will stop at the first error:

```elixir
FunPark.Maintenance.add_to_all(invalid_apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Left{
  left: %FunPark.Errors.ValidationError{errors: ["Apple Cart: wait time must be non negative"]}
}
```

But removing it will attempt all removals independently, returning a list of validation errors:

```elixir
FunPark.Maintenance.remove_from_all(invalid_apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Left{
  left: %FunPark.Errors.ValidationError{
    errors: ["Apple Cart: wait time must be non negative",
     "Apple Cart: wait time must be non negative", "Apple Cart: wait time must be non negative",
     "Apple Cart: wait time must be non negative"]
  }
}
```

Now let's try a valid ride with a broken store:

```elixir
FunPark.Store.drop_table(:schedule)
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{right: :schedule}
```

With add_to_all/1, the internal bind/2 will halt on the first error:

```elixir
FunPark.Maintenance.add_to_all(apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Left{
  left: %ArgumentError{
    message: "errors were found at the given arguments:\n\n  * 1st argument: the table identifier does not refer to an existing ETS table\n"
  }
}
```

But remove_from_all/1, uses sequence_a/1, and will independently run all removal effects:

```elixir
FunPark.Maintenance.remove_from_all(apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Left{
  left: [
    %ArgumentError{
      message: "errors were found at the given arguments:\n\n  * 1st argument: the table identifier does not refer to an existing ETS table\n"
    }
  ]
}
```

## Inject Behavior, Not Configuration

````markdown
```elixir
def add_ride_effect(%Ride{} = ride) do
  ride
  |> validate_ride_effect()
  |> Monad.bind(&add_to_store_effect/1)
end
```
````

````markdown
```elixir
def has_ride_effect(%Ride{} = ride) do
  Effect.asks(fn %{store: store, table: table_name} ->
    store.get(ride, table_name)
  end)
  |> Effect.bind(& &1)
end
```
````

````markdown
```elixir
def in_schedule(%Ride{} = ride) do
  has_ride_effect(ride)
  |> Effect.map_env(fn env -> Map.put(env, :table, :schedule) end)
end

def in_unschedule(%Ride{} = ride) do
  has_ride_effect(ride)
  |> Effect.map_env(fn env -> Map.put(env, :table, :unschedule) end)
end

def in_lockout(%Ride{} = ride) do
  has_ride_effect(ride)
  |> Effect.map_env(fn env -> Map.put(env, :table, :lockout) end)
end

def in_compliance(%Ride{} = ride) do
  has_ride_effect(ride)
  |> Effect.map_env(fn env -> Map.put(env, :table, :compliance) end)
end
```
````

Again, let's create the store and make an Apple Cart ride:

```elixir
FunPark.Maintenance.Repo.create_store()
apple = FunPark.Ride.make("Apple Cart")
```

<!-- livebook:{"output":true} -->

```
%FunPark.Ride{
  id: 1539,
  name: "Apple Cart",
  min_age: 0,
  min_height: 0,
  wait_time: 0,
  online: true,
  tags: []
}
```

Next, generate an Effect to check if it is in scheduled maintenance:

```elixir
effect = FunPark.Maintenance.Repo.in_schedule(apple)
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Effect.Right{
  effect: #Function<2.796317/1 in FunPark.Monad.FunPark.Monad.Effect.Right.map/2>
}
```

and create the environment with our Store:

```elixir
env = %{store: FunPark.Maintenance.Store}
```

<!-- livebook:{"output":true} -->

```
%{store: FunPark.Maintenance.Store}
```

When we run the Effect in the environment:

```elixir
FunPark.Monad.Effect.run(effect, env)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 502ms
Task completed in 502ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Left{left: :not_found}
```

But if we add Apple Cart to scheduled maintenance:

```elixir
FunPark.Maintenance.Repo.add_schedule(apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{
  right: %FunPark.Ride{
    id: 1539,
    name: "Apple Cart",
    min_age: 0,
    min_height: 0,
    wait_time: 0,
    online: true,
    tags: []
  }
}
```

and rerun our Effect:

```elixir
FunPark.Monad.Effect.run(effect, env)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{
  right: %FunPark.Ride{
    id: 1539,
    name: "Apple Cart",
    min_age: 0,
    min_height: 0,
    wait_time: 0,
    online: true,
    tags: []
  }
}
```

````markdown
```elixir
def check_in_all(%Ride{} = ride) do
  env = %{store: Maintenance.Store}
  
  ride
  |> Maintenance.Repo.in_schedule()
  |> Monad.bind(&Maintenance.Repo.in_unschedule/1)
  |> Monad.bind(&Maintenance.Repo.in_lockout/1)
  |> Monad.bind(&Maintenance.Repo.in_compliance/1)
  |> Effect.run(env)
end
```
````

We start by creating our store and generating a new ride:

```elixir
FunPark.Maintenance.Repo.create_store()
apple = FunPark.Ride.make("Apple Cart")
```

<!-- livebook:{"output":true} -->

```
%FunPark.Ride{
  id: 1603,
  name: "Apple Cart",
  min_age: 0,
  min_height: 0,
  wait_time: 0,
  online: true,
  tags: []
}
```

Since nothing has been added yet, check_in_all/1 fails with a Left:

```elixir
FunPark.Maintenance.check_in_all(apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Left{left: :not_found}
```

If we add the ride to all four maintenance tables:

```elixir
FunPark.Maintenance.add_to_all(apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{
  right: %FunPark.Ride{
    id: 1603,
    name: "Apple Cart",
    min_age: 0,
    min_height: 0,
    wait_time: 0,
    online: true,
    tags: []
  }
}
```

And rerun check_in_all/1:

```elixir
FunPark.Maintenance.check_in_all(apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 1002ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 1503ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 2004ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{
  right: %FunPark.Ride{
    id: 1603,
    name: "Apple Cart",
    min_age: 0,
    min_height: 0,
    wait_time: 0,
    online: true,
    tags: []
  }
}
```

We remove it from our :lockout table:

```elixir
FunPark.Maintenance.Repo.remove_lockout(apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 1ms
Task completed in 502ms
Task completed in 502ms
Task completed in 502ms
Task completed in 502ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{
  right: %FunPark.Ride{
    id: 1603,
    name: "Apple Cart",
    min_age: 0,
    min_height: 0,
    wait_time: 0,
    online: true,
    tags: []
  }
}
```

Once again, if we run our check_in_all/1:

```elixir
FunPark.Maintenance.check_in_all(apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 1002ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 1503ms
Task completed in 1503ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Left{left: :not_found}
```

## Flip the Logic

````markdown
```elixir
def assert_absent_effect(%Ride{} = ride, check_fn) do
  ride
  |> check_fn.()
  |> Effect.flip_either()
  |> Effect.bind(&right_if_absent/1)
  |> Effect.map_left(&replace_ride_with_reason/1)
end
```
````

````markdown
```elixir
def not_in_schedule(%Ride{} = ride) do
  assert_absent_effect(ride, &in_schedule/1)
end

def not_in_unschedule(%Ride{} = ride) do
  assert_absent_effect(ride, &in_unschedule/1)
end

def not_in_lockout(%Ride{} = ride) do
  assert_absent_effect(ride, &in_lockout/1)
end

def not_in_compliance(%Ride{} = ride) do
  assert_absent_effect(ride, &in_compliance/1)
end
```
````

````markdown
```elixir
def check_online_bind(%Ride{} = ride) do
  env = %{store: Maintenance.Store}
  
  ride
  |> Maintenance.Repo.not_in_schedule()
  |> Monad.bind(&Maintenance.Repo.not_in_unschedule/1)
  |> Monad.bind(&Maintenance.Repo.not_in_lockout/1)
  |> Monad.bind(&Maintenance.Repo.not_in_compliance/1)
  |> Effect.run(env)
end
```
````

Again, start by creating the store and a ride:

```elixir
FunPark.Maintenance.Repo.create_store()
apple = FunPark.Ride.make("Apple Cart")
```

<!-- livebook:{"output":true} -->

```
%FunPark.Ride{
  id: 1667,
  name: "Apple Cart",
  min_age: 0,
  min_height: 0,
  wait_time: 0,
  online: true,
  tags: []
}
```

And let's clean up the store to be certain Apple Cart is not saved:

```elixir
FunPark.Maintenance.remove_from_all(apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{
  right: %FunPark.Ride{
    id: 1667,
    name: "Apple Cart",
    min_age: 0,
    min_height: 0,
    wait_time: 0,
    online: true,
    tags: []
  }
}
```

Then check whether it's online:

```elixir
FunPark.Maintenance.check_online_bind(apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 501ms
Task completed in 1002ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 501ms
Task completed in 1503ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 501ms
Task completed in 2004ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{
  right: %FunPark.Ride{
    id: 1667,
    name: "Apple Cart",
    min_age: 0,
    min_height: 0,
    wait_time: 0,
    online: true,
    tags: []
  }
}
```

Now let's add it back to all the tables:

```elixir
FunPark.Maintenance.add_to_all(apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{
  right: %FunPark.Ride{
    id: 1667,
    name: "Apple Cart",
    min_age: 0,
    min_height: 0,
    wait_time: 0,
    online: true,
    tags: []
  }
}
```

When we run the check again, we get an answer in just half a second:

```elixir
FunPark.Maintenance.check_online_bind(apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Left{left: "Apple Cart is in scheduled maintenance"}
```

````markdown
```elixir
def online?(%Ride{} = ride) do
  ride |> check_online() |> Either.right?()
end
```
````

````markdown
```elixir
def online?(%Ride{} = ride) do
  ride |> Maintenance.check_online() |> Either.right?()
end
```
````

````markdown
```elixir
def ensure_online(%FunPark.Ride{online: false} = ride) do
  Left.pure(ValidationError.new("#{ride.name} is offline"))
end

def ensure_online(ride), do: Right.pure(ride)
```
````

````markdown
```elixir
def ensure_online(%Ride{} = ride) do
  case Maintenance.check_online(ride) do
    %Either.Right{} -> Either.Right.pure(ride)
    %Either.Left{left: reason} -> Either.Left.pure(ValidationError.new(reason))
  end
end
```
````

````markdown
```elixir
def check_online(%Ride{} = ride) do
  env = %{store: Maintenance.Store}
  validators = [
    &Maintenance.Repo.not_in_schedule/1,
    &Maintenance.Repo.not_in_unschedule/1,
    &Maintenance.Repo.not_in_lockout/1,
    &Maintenance.Repo.not_in_compliance/1
  ]
  
  Effect.validate(ride, validators)
  |> Effect.run(env)
end
```
````

Let's clean up by removing Apple Cart from every table:

```elixir
FunPark.Maintenance.remove_from_all(apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 502ms
Task completed in 502ms
Task completed in 502ms
Task completed in 502ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{
  right: %FunPark.Ride{
    id: 1667,
    name: "Apple Cart",
    min_age: 0,
    min_height: 0,
    wait_time: 0,
    online: true,
    tags: []
  }
}
```

And check whether it's online:

```elixir
FunPark.Maintenance.check_online(apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{
  right: %FunPark.Ride{
    id: 1667,
    name: "Apple Cart",
    min_age: 0,
    min_height: 0,
    wait_time: 0,
    online: true,
    tags: []
  }
}
```

And if we add it back to all the tables:

```elixir
FunPark.Maintenance.add_to_all(apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{
  right: %FunPark.Ride{
    id: 1667,
    name: "Apple Cart",
    min_age: 0,
    min_height: 0,
    wait_time: 0,
    online: true,
    tags: []
  }
}
```

When we run the check:

```elixir
FunPark.Maintenance.check_online(apple)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 502ms
Task completed in 502ms
Task completed in 502ms
Task completed in 502ms
Task completed in 502ms
Task completed in 502ms
Task completed in 502ms
Task completed in 502ms
Task completed in 502ms
Task completed in 502ms
Task completed in 502ms
Task completed in 502ms
Task completed in 502ms
Task completed in 502ms
Task completed in 502ms
Task completed in 502ms
Task completed in 502ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 502ms
Task completed in 502ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Left{
  left: ["Apple Cart is out of compliance", "Apple Cart is locked out",
   "Apple Cart is in unscheduled maintenance", "Apple Cart is in scheduled maintenance"]
}
```

````markdown
```elixir
def validate_fast_pass_lane_b(patron, ride) do
  patron
  |> validate_eligibility(ride)
  |> Monad.bind(&ensure_vip_or_fast_pass(&1, ride))
  |> Monad.bind(fn validated_patron ->
    case Maintenance.ensure_online(ride) do
      %Either.Right{} -> Either.Right.pure(validated_patron)
      %Either.Left{} = left -> left
    end
  end)
end
```
````

First, let's make sure our store is created, and generate a couple of patrons and a ride:

```elixir
FunPark.Maintenance.Repo.create_store()

beth = FunPark.Patron.make("Beth", 16, 115)
elsie = FunPark.Patron.make("Elsie", 17, 135, ticket_tier: :vip)

haunted_mansion = FunPark.Ride.make(
  "Haunted Mansion", 
  min_age: 14, 
  min_height: 120
)
```

<!-- livebook:{"output":true} -->

```
%FunPark.Ride{
  id: 1859,
  name: "Haunted Mansion",
  min_age: 14,
  min_height: 120,
  wait_time: 0,
  online: true,
  tags: []
}
```

And check if Beth can enter the fast pass lane:

```elixir
FunPark.Ride.FastLane.validate_fast_pass_lane_b(beth, haunted_mansion)
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Left{
  left: %FunPark.Errors.ValidationError{
    errors: ["Beth is not tall enough", "Beth does not have a fast pass"]
  }
}
```

Let's check Elsie:

```elixir
FunPark.Ride.FastLane.validate_fast_pass_lane_b(elsie, haunted_mansion)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 501ms
Task completed in 0ms
Task completed in 501ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{
  right: %FunPark.Patron{
    id: 1795,
    name: "Elsie",
    age: 17,
    height: 135,
    ticket_tier: :vip,
    fast_passes: [],
    reward_points: 0,
    likes: [],
    dislikes: []
  }
}
```

Later, the Haunted Mansion throws a fault and triggers a lockout:

```elixir
FunPark.Maintenance.Repo.add_lockout(haunted_mansion)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Right{
  right: %FunPark.Ride{
    id: 1859,
    name: "Haunted Mansion",
    min_age: 14,
    min_height: 120,
    wait_time: 0,
    online: true,
    tags: []
  }
}
```

Now, when we check Elsie:

```elixir
FunPark.Ride.FastLane.validate_fast_pass_lane_b(elsie, haunted_mansion)
```

<!-- livebook:{"output":true} -->

```
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 501ms
Task completed in 0ms
Task completed in 0ms
Task completed in 0ms
Task completed in 501ms
Task completed in 0ms
Task completed in 501ms
Task completed in 501ms
```

<!-- livebook:{"output":true} -->

```
%FunPark.Monad.Either.Left{
  left: %FunPark.Errors.ValidationError{errors: ["Haunted Mansion is locked out"]}
}
```
